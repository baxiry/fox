
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>إدارة الذاكرة في Fox</title>
  <style>
    body {
      background-color: #0f1117;
      color: #e6e6e6;
      font-family: "Segoe UI", Tahoma, sans-serif;
      line-height: 1.8;
      margin: 0;
      padding: 40px;
    }

    h1, h2, h3 {
      color: #7dd3fc;
    }

    p {
      max-width: 900px;
    }

    ul {
      max-width: 900px;
    }

    li {
      margin-bottom: 8px;
    }

    pre {
      direction: ltr;
      text-align: left;
      background: #111827;
      color: #e5e7eb;
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      max-width: 900px;
      margin: 16px 0;
      font-size: 14px;
    }

    code {
      direction: ltr;
      color: #93c5fd;
    }

    .note {
      background: #1f2933;
      border-right: 4px solid #38bdf8;
      padding: 12px 16px;
      margin: 20px 0;
      max-width: 900px;
    }

    .error {
      border-right-color: #f87171;
    }

    .ok {
      border-right-color: #4ade80;
    }
  </style>
</head>
<body>

<h1>إدارة الذاكرة في لغة Fox</h1>

<p>
Fox لغة مصممة لتقديم <strong>أمان ذاكرة حتمي بدون Runtime وبدون Garbage Collector</strong>.
بدل الاعتماد على تتبع وقت التشغيل، تعتمد Fox على تحليل الأعمار (Lifetimes)
وتتبّع المؤشرات وقت الترجمة فقط.
</p>

---

<h2>الفلسفة الأساسية</h2>

<p>
Fox لا تستخدم مفهوم “الملكية” كما في Rust،
ولا تعتمد على GC كما في Go.
السؤال الوحيد الذي يهم المترجم هو:
</p>

<div class="note">
<strong>هل يمكن إثبات متى ينتهي عمر هذا الكائن؟</strong>
</div>

<p>
إذا كان الجواب نعم → الكود مقبول  
إذا كان الجواب لا → فشل ترجمة واضح وصريح
</p>

---

<h2>قاعدة 1: العمر يجب أن يكون قابلاً للإثبات</h2>

<p>
كل كائن يتم إنشاؤه يجب أن يستطيع المترجم تحديد:
</p>

<ul>
  <li>أين بدأ عمره</li>
  <li>أين آخر استخدام له عبر كل المسارات</li>
  <li>أين يتم تحريره (أو حقن التحرير)</li>
</ul>

<pre><code>// مقبول
func f() {
    u := User{}
    print(u.Name)
    // compiler injects free(u) here
}</code></pre>

---

<h2>قاعدة 2: تعدد aliases مسموح</h2>

<p>
Fox تسمح بوجود عدة أسماء (aliases) لنفس الكائن.
هذا ليس خطأ، ولا يتعارض مع الأمان.
</p>

<pre><code>// مقبول
u := User{}
a := &u
b := a
c := b
use(c)</code></pre>

<div class="note ok">
المهم: كل aliases مرئية للمحلل ولم تخرج من نطاق التحليل.
</div>

---

<h2>قاعدة 3: ما يُمنع هو المؤشر غامض العمر</h2>

<p>
يُرفض الكود فقط إذا خرج المؤشر إلى مكان
لا يستطيع المترجم معرفة ما يحدث فيه.
</p>

<pre><code>// ❌ مرفوض
func leak(p *User) {
    global = p
}

func f() {
    u := User{}
    leak(&u)
}</code></pre>

<div class="note error">
المشكلة ليست في المؤشر نفسه،  
بل في فقدان المترجم القدرة على تتبع عمره.
</div>

---

<h2>قاعدة 4: الإرجاع بالمؤشر مسموح إذا كان العمر واضحًا</h2>

<p>
إرجاع مؤشر من دالة ليس خطأ بحد ذاته.
هو مقبول إذا لم يتم تسريب المؤشر قبل الإرجاع.
</p>

<pre><code>// مقبول
func makeUser() *User {
    u := User{}
    return &u
}</code></pre>

<div class="note ok">
عمر u يصبح عمر القيمة المرجعة.
لا يوجد غموض، ولا حاجة لنسخ.
</div>

---

<h2>قاعدة 5: متى يفشل التحليل؟</h2>

<p>
إذا لم يستطع المترجم إثبات أن المؤشر:
</p>

<ul>
  <li>لم يُخزَّن في مكان خارجي</li>
  <li>لم يُنسخ إلى نطاق غير معروف</li>
  <li>لم يُشارك مع خيوط بعمر غير محدد</li>
</ul>

<p>
فإن الترجمة تفشل، ويُطلب من المطور التدخل.
</p>

---

<h2>خلاصات أعمار المؤشرات (Function Summaries)</h2>

<p>
Fox لا تحتاج لعمل inline كامل لكل دالة.
بدل ذلك، يولد المترجم <strong>خلاصة عمر</strong> لكل دالة أو ميثود.
</p>

<h3>ما هي خلاصة العمر؟</h3>

<ul>
  <li>هل الدالة تحتفظ بالمؤشر؟</li>
  <li>هل تسربه إلى متغير خارجي؟</li>
  <li>هل تخزنه في بنية أطول عمرًا؟</li>
  <li>هل تستخدمه فقط مؤقتًا؟</li>
</ul>

<pre><code>// Summary: does not escape pointer
func inspect(p *User) {
    print(p.Name)
}</code></pre>

<pre><code>// Summary: escapes pointer
func store(p *User) {
    cache = p
}</code></pre>

<div class="note">
بفضل هذه الخلاصات، يمكن للمترجم:
<ul>
  <li>السماح بالتحليل العميق عبر الحزم</li>
  <li>منع الحالات الخطرة فقط</li>
  <li>تقديم رسائل خطأ دقيقة ومفهومة</li>
</ul>
</div>

---

<h2>الدوال الخارجية والحزم</h2>

<p>
إذا كانت الدالة من حزمة خارجية:
</p>

<ul>
  <li>إن وُجدت خلاصة → يُستخدم التحليل</li>
  <li>إن لم توجد خلاصة → يُعتبر المؤشر غامضًا</li>
</ul>

<pre><code>// ❌ مرفوض: دالة خارجية بلا خلاصة
external.Process(&u)</code></pre>

<div class="note error">
الغموض هنا ليس خطأ المطور،  
بل نقص معلومات → Fox ترفض بصراحة.
</div>

---

<h2>خلاصة نهائية</h2>

<div class="note ok">
Fox لا تقول: “من يملك هذا الكائن؟”  
بل تقول:  
<strong>“أثبت لي متى ينتهي عمره”</strong>
</div>

<p>
هذا يجعل Fox:
</p>

<ul>
  <li>آمنة جدًا</li>
  <li>بلا runtime</li>
  <li>قابلة للتحليل الكامل</li>
  <li>وأقرب للمنطق البشري من أنظمة الملكية الصارمة</li>
</ul>

<h2>الكائنات المشتركة بين الخيوط في Fox</h2>

<p>
Fox لا تفرض نموذج تزامن واحد (مثل القنوات في Go)،
ولا تعتمد على runtime لإدارة التزامن.
الأصل في Fox هو:
</p>

<div class="note">
<strong>المشاركة بين الخيوط مسموحة فقط إذا كانت مرئية ومثبتة ومُدارة صراحة.</strong>
</div>

---

<h3>قاعدة أساسية</h3>

<p>
أي كائن يمكن الوصول إليه من أكثر من خيط يجب أن يكون:
</p>

<ul>
  <li>عمره أطول من جميع الخيوط التي تستخدمه</li>
  <li>وصوله المتزامن مضبوطًا (Locks / Atomics)</li>
  <li>غير غامض للمحلل</li>
</ul>

<p>
إذا فشل أي شرط → فشل ترجمة.
</p>

---

<h3>متى يعتبر الكائن «مشتركًا»؟</h3>

<p>
يُعتبر الكائن مشتركًا إذا:
</p>

<ul>
  <li>تم تمرير مؤشره إلى خيط آخر</li>
  <li>أو تم تخزينه في بنية مرئية لخيوط متعددة</li>
  <li>أو عاد من دالة تنشئ خيطًا</li>
</ul>

<pre><code>// ❌ مرفوض
func f() {
    u := User{}
    spawn(func() {
        use(&u)
    })
}</code></pre>

<div class="note error">
الخيط قد يستمر بعد خروج u من نطاقه.
العمر غير قابل للإثبات.
</div>

---

<h3>الحل الصحيح: توسيع العمر صراحة</h3>

<p>
إذا أراد المطور مشاركة كائن بين الخيوط،
فعليه جعله ذا عمر واضح وطويل.
</p>

<pre><code>// ✔ مقبول
func f() {
    u := &User{}   // كائن ذو عمر ممتد
    spawn(func() {
        use(u)
    })
}</code></pre>

<div class="note ok">
أخذ العنوان صراحة يخبر المترجم:
هذا الكائن ليس محليًا.
</div>

---

<h3>التحرير في الكائنات المشتركة</h3>

<p>
Fox لا تحرر تلقائيًا كائنًا مشتركًا بين الخيوط.
</p>

<ul>
  <li>لا حقن free تلقائي</li>
  <li>لا افتراض انتهاء العمر</li>
  <li>التحرير يصبح مسؤولية المطور</li>
</ul>

<pre><code>// مثال
u := &User{}
spawn(worker1(u))
spawn(worker2(u))

// لاحقًا بعد join
free(u)</code></pre>

<div class="note">
بمجرد دخول الكائن عالم التشارك،
تنتقل مسؤوليته من التحليل الحتمي
إلى إدارة صريحة من المطور.
</div>

---

<h3>الأقفال (Locks)</h3>

<p>
Fox لا تفرض نوع قفل معين،
لكنها تتطلب أن يكون التزامن مرئيًا.
</p>

<pre><code>
type Shared struct {
    lock Mutex
    value int
}

func (s *Shared) Inc() {
    s.lock.Lock()
    s.value++
    s.lock.Unlock()
}</code></pre>

<div class="note ok">
المترجم يرى بوضوح:
<ul>
  <li>الكائن مشترك</li>
  <li>الوصول محمي</li>
  <li>لا يوجد سباق غير مضبوط</li>
</ul>
</div>

---

<h3>العمليات الذرية (Atomics)</h3>

<p>
Fox تدعم العمليات الذرية كمكتبة مستقلة.
</p>

<pre><code>
var counter atomic.Int64

spawn(func() {
    counter.Add(1)
})</code></pre>

<p>
الأنواع الذرية:
</p>

<ul>
  <li>لا تحتاج أقفال</li>
  <li>مُعرفة بوضوح للمترجم</li>
  <li>مسموح مشاركتها دون قيود إضافية</li>
</ul>

---

<h3>ما الذي يمنعه المترجم؟</h3>

<p>
المترجم يمنع فقط الحالات التالية:
</p>

<ul>
  <li>مشاركة كائن محلي دون توسيع عمره</li>
  <li>تحرير كائن بينما خيط آخر قد يستخدمه</li>
  <li>الوصول المتزامن بدون Lock أو Atomic</li>
</ul>

<pre><code>// ❌ مرفوض
func f() {
    u := &User{}
    spawn(use(u))
    free(u)
}</code></pre>

<div class="note error">
لا يمكن إثبات أن الخيط انتهى قبل free.
</div>

---

<h3>مقارنة سريعة مع Go و Rust</h3>

<ul>
  <li><strong>Go:</strong> يسمح بكل شيء ثم ينهار وقت التشغيل</li>
  <li><strong>Rust:</strong> يمنع كثيرًا حتى الحالات الصحيحة</li>
  <li><strong>Fox:</strong> يسمح إذا ثبت، ويمنع إذا غمض</li>
</ul>

<div class="note ok">
Fox لا تفترض حسن النية،
ولا تفترض سوء النية،
بل تطلب الدليل.
</div>
</body>
</html>
